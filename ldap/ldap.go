package ldap

import (
	"crypto/tls"
	"fmt"
	"time"

	"github.com/go-ldap/ldap"
	"github.com/mattermost/platform/api"
	"github.com/mattermost/platform/einterfaces"
	"github.com/mattermost/platform/model"
	"github.com/mattermost/platform/utils"
)

type LDAPClient struct {
	cfg  *model.LdapSettings
	conn *ldap.Conn
}

func NewLdapInterface() einterfaces.LdapInterface {
	cfg := &utils.Cfg.LdapSettings
	return &LDAPClient{cfg: cfg}
}

func (lp *LDAPClient) connect() (conn *ldap.Conn, err error) {
	ldap.DefaultTimeout = time.Duration(*lp.cfg.QueryTimeout) * time.Second
	if *lp.cfg.ConnectionSecurity == "TLS" {
		conn, err = ldap.DialTLS("tcp", fmt.Sprintf("%s:%d", *lp.cfg.LdapServer, *lp.cfg.LdapPort), &tls.Config{InsecureSkipVerify: *lp.cfg.SkipCertificateVerification, ServerName: *lp.cfg.LdapServer})
	} else {
		conn, err = ldap.Dial("tcp", fmt.Sprintf("%s:%d", *lp.cfg.LdapServer, *lp.cfg.LdapPort))
	}
	return
}

func (lp *LDAPClient) bindRoot(conn *ldap.Conn) (err error) {
	err = conn.Bind(*lp.cfg.BindUsername, *lp.cfg.BindPassword)
	return
}

func (lp *LDAPClient) getUserByUID(uid string) (conn *ldap.Conn, entry *ldap.Entry, user *model.User, err error) {
	conn, err = lp.connect()
	if err != nil {
		fmt.Printf("Cannot create connection: %#u\n", err)
		return
	}

	err = lp.bindRoot(conn)
	if err != nil {
		conn.Close()
		fmt.Printf("Cannot bind for search: %#u\n", err)
		return
	}

	result, err := conn.Search(&ldap.SearchRequest{
		BaseDN: *lp.cfg.BaseDN,
		Scope:  ldap.ScopeWholeSubtree,
		Filter: fmt.Sprintf("(&(%s=%s)%s)", *lp.cfg.LoginFieldName, ldap.EscapeFilter(uid), *lp.cfg.UserFilter)})
	if err != nil {
		fmt.Printf("Cannot search for user: %#u\n", err)
		return
	}

	if len(result.Entries) != 1 {
		err = fmt.Errorf("User %s not found!", uid)
		return
	}

	entry = result.Entries[0]

	authData := entry.GetAttributeValue(*lp.cfg.LoginFieldName)
	user = &model.User{
		AuthService: model.USER_AUTH_SERVICE_LDAP,
		FirstName:   entry.GetAttributeValue(*lp.cfg.FirstNameAttribute),
		LastName:    entry.GetAttributeValue(*lp.cfg.LastNameAttribute),
		Email:       entry.GetAttributeValue(*lp.cfg.EmailAttribute),
		Username:    entry.GetAttributeValue(*lp.cfg.UsernameAttribute),
		AuthData:    &authData,
		Nickname:    entry.GetAttributeValue(*lp.cfg.NicknameAttribute),
		//Id should be generated by mattermost
		//Id: entry.GetAttributeValue(*lp.cfg.IdAttribute),
	}

	return
}

func (lp *LDAPClient) DoLogin(id string, password string) (user *model.User, errApp *model.AppError) {
	fmt.Printf("Started DoLogin\n")
	conn, entry, user, err := lp.getUserByUID(id)
	if err != nil {
		return nil, model.NewLocAppError("ldap.DoLogin", fmt.Sprint(err), nil, "")
	}
	defer conn.Close()

	err = conn.Bind(entry.DN, password)
	if err != nil {
		return nil, model.NewLocAppError("ldap.DoLogin", "LDAP auth failed, incorrect password", nil, "")
	}

	if !api.IsUsernameTaken(user.Username) {
		ruser, errApp := api.CreateUser(user)
		if errApp != nil {
			return nil, errApp
		}
		return ruser, nil
	} else if result := <-api.Srv.Store.User().GetForLogin(*user.AuthData, false, false, true); result.Err != nil {
		return nil, result.Err
	} else {
		return result.Data.(*model.User), nil
	}

	return user, nil
}

func (lp *LDAPClient) GetUser(id string) (*model.User, *model.AppError) {
	fmt.Printf("Started GetUser\n")
	conn, _, user, errAp := lp.getUserByUID(id)

	conn.Close()

	if errAp != nil {
		return nil, model.NewLocAppError("ldap.GetUser", "Cannot get user from LDAP", nil, "")
	}

	if result := <-api.Srv.Store.User().GetForLogin(*user.AuthData, false, false, true); result.Err != nil {
		return user, nil
	} else {
		return result.Data.(*model.User), nil
	}
}

func (lp *LDAPClient) CheckPassword(id string, password string) *model.AppError {
	fmt.Printf("Started CheckPassword\n")
	conn, entry, _, err := lp.getUserByUID(id)
	if err != nil {
		return model.NewLocAppError("ldap.CheckPassword", "Cannot get user from LDAP", nil, "")
	}
	defer conn.Close()

	err = conn.Bind(entry.DN, password)
	if err != nil {
		return model.NewLocAppError("ldap.CheckPassword", fmt.Sprintf("LDAP auth failed: %v", err), nil, "")
	}

	return nil
}

func (lp *LDAPClient) SwitchToLdap(userId, ldapId, ldapPassword string) *model.AppError {
	// called from api/user.go: emailToLdap
	// not implemented yet
	fmt.Printf("Started SwitchToLdap\n")
	return nil
}

func (lp *LDAPClient) ValidateFilter(filter string) *model.AppError {
	fmt.Printf("Started ValidateFilter\n")
	_, err := ldap.CompileFilter(filter)
	if err != nil {
		return model.NewLocAppError("ldap.ValidateFilter", fmt.Sprintf("Cannot LDAP validate filter: %v", err), nil, "")
	}
	return nil
}

func (lp *LDAPClient) StartLdapSyncJob() {
}

func (lp *LDAPClient) Syncronize() *model.AppError {
	return nil
}
